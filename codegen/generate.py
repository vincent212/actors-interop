#!/usr/bin/env python3
"""
Code generator for C++/Rust FFI interop messages.

Parses interop_messages.h and generates:
1. C++ message classes (InteropMessages.hpp)
2. Rust message structs (interop_messages.rs)
3. C++ bridge functions (CppActorBridge.hpp/cpp)
4. Rust bridge functions (rust_actor_bridge.rs)

Usage:
    python3 generate.py messages/interop_messages.h generated/
"""

import re
import sys
import os
from dataclasses import dataclass, field
from typing import List, Optional, Tuple

@dataclass
class Field:
    name: str
    c_type: str
    is_string: bool = False
    is_bool: bool = False
    array_size: Optional[int] = None  # None if not an array

@dataclass
class Message:
    name: str
    msg_id: int
    fields: List[Field]

def parse_header(header_path: str) -> List[Message]:
    """Parse interop_messages.h and extract message definitions."""
    with open(header_path, 'r') as f:
        content = f.read()

    messages = []

    # Find all INTEROP_MESSAGE annotations followed by struct definitions
    pattern = r'INTEROP_MESSAGE\s*\(\s*(\w+)\s*,\s*(\d+)\s*\)\s*typedef\s+struct\s*\{([^}]*)\}\s*(\w+)\s*;'

    for match in re.finditer(pattern, content, re.DOTALL):
        name = match.group(1)
        msg_id = int(match.group(2))
        struct_body = match.group(3)
        struct_name = match.group(4)

        assert name == struct_name, f"Mismatch: {name} vs {struct_name}"

        fields = []
        # Match: type name; or type name[size];
        for field_match in re.finditer(r'(\w+)\s+(\w+)(?:\[(\d+)\])?\s*;', struct_body):
            c_type = field_match.group(1)
            field_name = field_match.group(2)
            array_size = int(field_match.group(3)) if field_match.group(3) else None

            is_string = c_type == 'interop_string'
            # Check for bool comment on the same line only (e.g., "int32_t found; /* bool: ...")
            line_end = struct_body.find('\n', field_match.end())
            if line_end == -1:
                line_end = len(struct_body)
            line_comment = struct_body[field_match.end():line_end]
            is_bool = ('bool' in line_comment.lower()) and array_size is None

            fields.append(Field(field_name, c_type, is_string, is_bool, array_size))

        messages.append(Message(name, msg_id, fields))

    return messages

def c_to_cpp_type(c_type: str, array_size: Optional[int] = None) -> str:
    """Convert C type to C++ type."""
    mapping = {
        'int32_t': 'int32_t',
        'int64_t': 'int64_t',
        'uint32_t': 'uint32_t',
        'uint64_t': 'uint64_t',
        'double': 'double',
        'float': 'float',
        'char': 'char',
        'interop_string': 'std::string',
    }
    base_type = mapping.get(c_type, c_type)
    if array_size:
        return f'std::array<{base_type}, {array_size}>'
    return base_type

def c_to_rust_type(c_type: str, array_size: Optional[int] = None) -> str:
    """Convert C type to Rust type."""
    mapping = {
        'int32_t': 'i32',
        'int64_t': 'i64',
        'uint32_t': 'u32',
        'uint64_t': 'u64',
        'double': 'f64',
        'float': 'f32',
        'char': 'u8',
        'interop_string': 'String',
    }
    base_type = mapping.get(c_type, c_type)
    if array_size:
        return f'[{base_type}; {array_size}]'
    return base_type

def c_to_rust_c_type(c_type: str, array_size: Optional[int] = None) -> str:
    """Convert C type to Rust FFI-compatible type."""
    mapping = {
        'int32_t': 'i32',
        'int64_t': 'i64',
        'uint32_t': 'u32',
        'uint64_t': 'u64',
        'double': 'f64',
        'float': 'f32',
        'char': 'u8',
        'interop_string': 'CInteropString',
    }
    base_type = mapping.get(c_type, c_type)
    if array_size:
        return f'[{base_type}; {array_size}]'
    return base_type

def generate_cpp_messages(messages: List[Message], output_dir: str):
    """Generate C++ message classes in msg:: namespace."""
    cpp_dir = os.path.join(output_dir, 'cpp')
    os.makedirs(cpp_dir, exist_ok=True)

    with open(os.path.join(cpp_dir, 'InteropMessages.hpp'), 'w') as f:
        f.write('''/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 */

#pragma once

#include <string>
#include <array>
#include <cstring>
#include <algorithm>
#include "actors/Message.hpp"
#include "interop_messages.h"

namespace msg {

''')

        for msg in messages:
            # Generate C++ class
            f.write(f'class {msg.name} : public actors::Message_N<{msg.msg_id}> {{\n')
            f.write('public:\n')
            f.write(f'    static constexpr int32_t ID = {msg.msg_id};\n\n')

            # Fields
            for field in msg.fields:
                cpp_type = c_to_cpp_type(field.c_type, field.array_size)
                if field.is_bool:
                    cpp_type = 'bool'
                f.write(f'    {cpp_type} {field.name};\n')

            f.write('\n')

            # Default constructor
            f.write(f'    {msg.name}() = default;\n\n')

            # Constructor with all fields
            if msg.fields:
                params = []
                for field in msg.fields:
                    if field.is_bool:
                        params.append(f'bool _{field.name}')
                    elif field.array_size:
                        cpp_type = c_to_cpp_type(field.c_type, field.array_size)
                        params.append(f'const {cpp_type}& _{field.name}')
                    else:
                        cpp_type = c_to_cpp_type(field.c_type)
                        params.append(f'{cpp_type} _{field.name}')

                init_list = ', '.join(f'{field.name}(_{field.name})' for field in msg.fields)
                f.write(f'    {msg.name}({", ".join(params)})\n')
                f.write(f'        : {init_list} {{}}\n\n')

            # to_c_struct()
            f.write(f'    ::{msg.name} to_c_struct() const {{\n')
            f.write(f'        ::{msg.name} c;\n')
            for field in msg.fields:
                if field.is_string:
                    f.write(f'        std::strncpy(c.{field.name}.data, {field.name}.c_str(), INTEROP_STRING_MAX - 1);\n')
                    f.write(f'        c.{field.name}.data[INTEROP_STRING_MAX - 1] = \'\\0\';\n')
                    f.write(f'        c.{field.name}.len = static_cast<uint32_t>({field.name}.size());\n')
                elif field.is_bool:
                    f.write(f'        c.{field.name} = {field.name} ? 1 : 0;\n')
                elif field.array_size:
                    f.write(f'        std::copy({field.name}.begin(), {field.name}.end(), c.{field.name});\n')
                else:
                    f.write(f'        c.{field.name} = {field.name};\n')
            f.write('        return c;\n')
            f.write('    }\n\n')

            # from_c_struct()
            f.write(f'    static {msg.name} from_c_struct(const ::{msg.name}& c) {{\n')
            f.write(f'        {msg.name} m;\n')
            for field in msg.fields:
                if field.is_string:
                    f.write(f'        m.{field.name} = std::string(c.{field.name}.data, c.{field.name}.len);\n')
                elif field.is_bool:
                    f.write(f'        m.{field.name} = c.{field.name} != 0;\n')
                elif field.array_size:
                    f.write(f'        std::copy(std::begin(c.{field.name}), std::end(c.{field.name}), m.{field.name}.begin());\n')
                else:
                    f.write(f'        m.{field.name} = c.{field.name};\n')
            f.write('        return m;\n')
            f.write('    }\n')

            f.write('};\n\n')

        f.write('} // namespace msg\n')

def generate_rust_messages(messages: List[Message], output_dir: str):
    """Generate Rust message structs."""
    rust_dir = os.path.join(output_dir, 'rust')
    os.makedirs(rust_dir, exist_ok=True)

    with open(os.path.join(rust_dir, 'interop_messages.rs'), 'w') as f:
        f.write('''//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h

#![allow(dead_code)]

pub const INTEROP_STRING_MAX: usize = 64;

/// Fixed-size string for FFI (matches C interop_string)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CInteropString {
    pub data: [u8; INTEROP_STRING_MAX],
    pub len: u32,
}

impl Default for CInteropString {
    fn default() -> Self {
        CInteropString {
            data: [0u8; INTEROP_STRING_MAX],
            len: 0,
        }
    }
}

impl CInteropString {
    pub fn from_str(s: &str) -> Self {
        let mut result = Self::default();
        let bytes = s.as_bytes();
        let copy_len = bytes.len().min(INTEROP_STRING_MAX - 1);
        result.data[..copy_len].copy_from_slice(&bytes[..copy_len]);
        result.len = copy_len as u32;
        result
    }

    pub fn to_string(&self) -> String {
        let len = self.len as usize;
        String::from_utf8_lossy(&self.data[..len]).to_string()
    }
}

''')

        # Message ID constants
        f.write('// Message ID constants\n')
        for msg in messages:
            f.write(f'pub const MSG_{msg.name.upper()}: i32 = {msg.msg_id};\n')
        f.write('\n')

        for msg in messages:
            # C-compatible struct (for FFI)
            f.write(f'/// C-compatible {msg.name} struct for FFI\n')
            f.write('#[repr(C)]\n')
            f.write('#[derive(Clone, Copy)]\n')
            f.write(f'pub struct C{msg.name} {{\n')
            for field in msg.fields:
                rust_type = c_to_rust_c_type(field.c_type, field.array_size)
                f.write(f'    pub {field.name}: {rust_type},\n')
            f.write('}\n\n')

            # Default impl
            f.write(f'impl Default for C{msg.name} {{\n')
            f.write('    fn default() -> Self {\n')
            f.write(f'        C{msg.name} {{\n')
            for field in msg.fields:
                if field.is_string:
                    f.write(f'            {field.name}: CInteropString::default(),\n')
                elif field.array_size:
                    if field.c_type in ('double', 'float'):
                        f.write(f'            {field.name}: [0.0; {field.array_size}],\n')
                    else:
                        f.write(f'            {field.name}: [0; {field.array_size}],\n')
                elif field.c_type == 'double' or field.c_type == 'float':
                    f.write(f'            {field.name}: 0.0,\n')
                else:
                    f.write(f'            {field.name}: 0,\n')
            f.write('        }\n')
            f.write('    }\n')
            f.write('}\n\n')

            # Rust-native struct
            f.write(f'/// Rust-native {msg.name} message\n')
            f.write('#[derive(Clone, Debug)]\n')
            f.write(f'pub struct {msg.name} {{\n')
            for field in msg.fields:
                rust_type = c_to_rust_type(field.c_type, field.array_size)
                if field.is_bool:
                    rust_type = 'bool'
                f.write(f'    pub {field.name}: {rust_type},\n')
            f.write('}\n\n')

            f.write(f'impl {msg.name} {{\n')
            f.write(f'    pub const ID: i32 = {msg.msg_id};\n\n')

            # to_c_struct()
            f.write(f'    pub fn to_c_struct(&self) -> C{msg.name} {{\n')
            f.write(f'        C{msg.name} {{\n')
            for field in msg.fields:
                if field.is_string:
                    f.write(f'            {field.name}: CInteropString::from_str(&self.{field.name}),\n')
                elif field.is_bool:
                    f.write(f'            {field.name}: if self.{field.name} {{ 1 }} else {{ 0 }},\n')
                else:
                    f.write(f'            {field.name}: self.{field.name},\n')
            f.write('        }\n')
            f.write('    }\n\n')

            # from_c_struct()
            f.write(f'    pub fn from_c_struct(c: &C{msg.name}) -> Self {{\n')
            f.write(f'        {msg.name} {{\n')
            for field in msg.fields:
                if field.is_string:
                    f.write(f'            {field.name}: c.{field.name}.to_string(),\n')
                elif field.is_bool:
                    f.write(f'            {field.name}: c.{field.name} != 0,\n')
                else:
                    f.write(f'            {field.name}: c.{field.name},\n')
            f.write('        }\n')
            f.write('    }\n')
            f.write('}\n\n')

            # Implement actors::Message trait so it can be sent via ActorRef
            f.write(f'/// Implement Message trait for actor messaging\n')
            f.write(f'impl actors::Message for {msg.name} {{\n')
            f.write(f'    fn as_any(&self) -> &dyn std::any::Any {{ self }}\n')
            f.write(f'    fn as_any_mut(&mut self) -> &mut dyn std::any::Any {{ self }}\n')
            f.write(f'    fn message_id(&self) -> i32 {{ {msg.msg_id} }}\n')
            f.write(f'}}\n\n')

def generate_cpp_bridge(messages: List[Message], output_dir: str):
    """Generate C++ bridge header and implementation."""
    cpp_dir = os.path.join(output_dir, 'cpp')

    # Header
    with open(os.path.join(cpp_dir, 'CppActorBridge.hpp'), 'w') as f:
        f.write('''/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * C++ Actor Bridge - extern "C" functions callable from Rust
 * Uses Manager's actor registry instead of a separate registry.
 */

#pragma once

#include <cstdint>

// Forward declaration
namespace actors { class Manager; }

extern "C" {

// Initialize the C++ actor bridge with a Manager pointer
// The Manager's registry is used to look up actors by name
void cpp_actor_init(actors::Manager* mgr);

// Shutdown the C++ actor runtime
void cpp_actor_shutdown();

// Check if a C++ actor exists (looks up in Manager's registry)
int32_t cpp_actor_exists(const char* name);

// Send a message to a C++ actor (async - called from Rust)
// sender_name is used to create an ActorRef for replies
// Returns 0 on success, -1 if actor not found, -2 if unknown message type
int32_t cpp_actor_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
);

// Send a message to a C++ actor (sync - blocks until processed)
// Returns 0 on success, -1 if actor not found, -2 if unknown message type
int32_t cpp_actor_fast_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
);

} // extern "C"
''')

    # Implementation
    with open(os.path.join(cpp_dir, 'CppActorBridge.cpp'), 'w') as f:
        f.write('''/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * Uses Manager's actor registry instead of a separate registry.
 */

#include "CppActorBridge.hpp"
#include "InteropMessages.hpp"
#include "RustActorIF.hpp"
#include "actors/Actor.hpp"
#include "actors/act/Manager.hpp"

#include <string>
#include <mutex>
#include <memory>
#include <unordered_map>

namespace {

// Global Manager pointer - set by cpp_actor_init()
actors::Manager* g_manager = nullptr;

/**
 * RustSenderProxy - A minimal Actor that forwards reply() calls back to Rust
 *
 * When a Rust actor sends a message to C++, we create one of these as the
 * "sender" so that the C++ actor can call reply() naturally. The proxy
 * intercepts the reply message and forwards it back to the Rust actor via FFI.
 */
class RustSenderProxy : public actors::Actor {
    interop::RustActorIF rust_actor_;

public:
    RustSenderProxy(const std::string& rust_actor_name, const std::string& cpp_actor_name)
        : rust_actor_(rust_actor_name, cpp_actor_name)
    {
        strncpy(name, rust_actor_name.c_str(), sizeof(name) - 1);
        name[sizeof(name) - 1] = '\\0';
    }

    // Override send to forward to Rust
    void send(const actors::Message* m, actors::Actor* sender) noexcept override {
        // Forward to Rust based on message type
''')

        # Generate dispatch for each message type
        for msg in messages:
            f.write(f'''        if (m->get_message_id() == {msg.msg_id}) {{
            rust_actor_.send(*static_cast<const msg::{msg.name}*>(m));
            delete m;
            return;
        }}
''')

        f.write('''        // Unknown message type, just delete it
        delete m;
    }
};

// Cache of proxy actors (reused across multiple messages from same sender)
std::unordered_map<std::string, std::unique_ptr<RustSenderProxy>> proxy_cache;
std::mutex proxy_mutex;

/**
 * Get or create a proxy actor for a Rust sender.
 * The proxy enables C++ actors to use reply() naturally.
 */
actors::Actor* get_sender_proxy(const char* sender_name, const char* receiver_name) {
    if (!sender_name || sender_name[0] == '\\0') {
        return nullptr;
    }

    std::string key = std::string(sender_name) + "->" + (receiver_name ? receiver_name : "");

    std::lock_guard<std::mutex> lock(proxy_mutex);
    auto it = proxy_cache.find(key);
    if (it != proxy_cache.end()) {
        return it->second.get();
    }

    // Create new proxy
    auto proxy = std::make_unique<RustSenderProxy>(sender_name, receiver_name ? receiver_name : "");
    auto* ptr = proxy.get();
    proxy_cache[key] = std::move(proxy);
    return ptr;
}

} // anonymous namespace

extern "C" {

void cpp_actor_init(actors::Manager* mgr) {
    g_manager = mgr;
}

void cpp_actor_shutdown() {
    std::lock_guard<std::mutex> lock(proxy_mutex);
    proxy_cache.clear();
    g_manager = nullptr;
}

int32_t cpp_actor_exists(const char* name) {
    if (!name || !g_manager) return 0;
    return g_manager->get_actor_by_name(name) != nullptr ? 1 : 0;
}

int32_t cpp_actor_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
) {
    if (!actor_name || !msg_data || !g_manager) return -1;

    actors::Actor* actor = g_manager->get_actor_by_name(actor_name);
    if (!actor) return -1;  // Actor not found

    actors::Actor* sender = get_sender_proxy(sender_name, actor_name);

    // Dispatch based on message type
    switch (msg_type) {
''')

        for msg in messages:
            f.write(f'        case {msg.msg_id}: {{\n')
            f.write(f'            auto* cpp_msg = new msg::{msg.name}(\n')
            f.write(f'                msg::{msg.name}::from_c_struct(\n')
            f.write(f'                    *static_cast<const ::{msg.name}*>(msg_data)\n')
            f.write(f'                )\n')
            f.write(f'            );\n')
            f.write(f'            actor->send(cpp_msg, sender);\n')
            f.write(f'            break;\n')
            f.write(f'        }}\n')

        f.write('''        default:
            return -2; // Unknown message type
    }

    return 0;
}

int32_t cpp_actor_fast_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
) {
    if (!actor_name || !msg_data || !g_manager) return -1;

    actors::Actor* actor = g_manager->get_actor_by_name(actor_name);
    if (!actor) return -1;  // Actor not found

    actors::Actor* sender = get_sender_proxy(sender_name, actor_name);

    // Dispatch based on message type (sync version)
    switch (msg_type) {
''')

        for msg in messages:
            f.write(f'        case {msg.msg_id}: {{\n')
            f.write(f'            msg::{msg.name} cpp_msg = msg::{msg.name}::from_c_struct(\n')
            f.write(f'                *static_cast<const ::{msg.name}*>(msg_data)\n')
            f.write(f'            );\n')
            f.write(f'            actor->fast_send(&cpp_msg, sender);\n')
            f.write(f'            break;\n')
            f.write(f'        }}\n')

        f.write('''        default:
            return -2; // Unknown message type
    }

    return 0;
}

} // extern "C"
''')

def generate_rust_bridge(messages: List[Message], output_dir: str):
    """Generate Rust bridge functions."""
    rust_dir = os.path.join(output_dir, 'rust')

    with open(os.path.join(rust_dir, 'rust_actor_bridge.rs'), 'w') as f:
        f.write('''//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h
//!
//! Rust Actor Bridge - extern "C" functions callable from C++
//!
//! Uses Rust Manager's actor registry instead of a separate registry.

#![allow(dead_code)]

use std::ffi::CStr;
use std::os::raw::{c_char, c_int, c_void};
use std::sync::Mutex;

use actors::{ActorRef, Manager};
use crate::interop_messages::*;

// Wrapper to make Manager pointer safe for static storage
struct ManagerPtr(*const Manager);
unsafe impl Send for ManagerPtr {}
unsafe impl Sync for ManagerPtr {}

// Global Manager pointer - set by rust_actor_init()
// We use Mutex with a wrapper type since raw pointers don't impl Send/Sync
static MANAGER: Mutex<ManagerPtr> = Mutex::new(ManagerPtr(std::ptr::null()));

/// Get reference to the global Manager
fn get_manager() -> Option<&'static Manager> {
    let guard = MANAGER.lock().ok()?;
    if guard.0.is_null() {
        return None;
    }
    // SAFETY: Manager is guaranteed to outlive the FFI calls
    Some(unsafe { &*guard.0 })
}

/// Create a CppActorRef for reply routing (wraps CppActorIF)
fn create_cpp_sender_ref(sender_name: &str, receiver_name: &str) -> Option<ActorRef> {
    // For now, we don't have a direct way to create a Rust ActorRef for C++ actors
    // The receiver will use CppActorIF directly for replies
    None
}

/// Initialize the Rust actor bridge with a Manager pointer
/// The Manager's registry is used to look up actors by name
#[no_mangle]
pub extern "C" fn rust_actor_init(mgr: *const Manager) {
    if let Ok(mut guard) = MANAGER.lock() {
        guard.0 = mgr;
    }
}

/// Shutdown the Rust actor runtime
#[no_mangle]
pub extern "C" fn rust_actor_shutdown() {
    if let Ok(mut guard) = MANAGER.lock() {
        guard.0 = std::ptr::null();
    }
}

/// Check if a Rust actor exists (looks up in Manager's registry)
#[no_mangle]
pub extern "C" fn rust_actor_exists(name: *const c_char) -> c_int {
    if name.is_null() {
        return 0;
    }
    let name_str = match unsafe { CStr::from_ptr(name).to_str() } {
        Ok(s) => s,
        Err(_) => return 0,
    };
    let mgr = match get_manager() {
        Some(m) => m,
        None => return 0,
    };
    if mgr.get_ref(name_str).is_some() { 1 } else { 0 }
}

/// Send a message to a Rust actor (async - called from C++)
/// sender_name is used to create a sender ActorRef for replies
/// Returns 0 on success, -1 if actor not found, -2 if unknown message type
#[no_mangle]
pub extern "C" fn rust_actor_send(
    actor_name: *const c_char,
    sender_name: *const c_char,
    msg_type: c_int,
    msg_data: *const c_void,
) -> c_int {
    if actor_name.is_null() || msg_data.is_null() {
        return -1;
    }

    let name = match unsafe { CStr::from_ptr(actor_name).to_str() } {
        Ok(s) => s,
        Err(_) => return -1,
    };

    let mgr = match get_manager() {
        Some(m) => m,
        None => return -1,
    };

    let actor_ref = match mgr.get_ref(name) {
        Some(r) => r,
        None => return -1,  // Actor not found
    };

    // Create sender ref for replies (if sender name provided)
    let sender_ref: Option<ActorRef> = if sender_name.is_null() {
        None
    } else {
        // For C++ senders, we create a special ActorRef that routes back via FFI
        // This is handled by the CppSenderProxy in the actor
        None // TODO: Implement CppActorRef
    };

    // Convert C struct to Rust message and send
    match msg_type {
''')
        # Generate message dispatch
        for msg in messages:
            f.write(f'''        {msg.msg_id} => {{
            let c_msg = unsafe {{ &*(msg_data as *const C{msg.name}) }};
            let rust_msg = {msg.name}::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }}
''')

        f.write('''        _ => return -2,  // Unknown message type
    }

    0  // Success
}

/// Send a message to a Rust actor (sync - blocks until processed)
/// Returns 0 on success, -1 if actor not found, -2 if unknown message type
#[no_mangle]
pub extern "C" fn rust_actor_fast_send(
    actor_name: *const c_char,
    sender_name: *const c_char,
    msg_type: c_int,
    msg_data: *const c_void,
) -> c_int {
    if actor_name.is_null() || msg_data.is_null() {
        return -1;
    }

    let name = match unsafe { CStr::from_ptr(actor_name).to_str() } {
        Ok(s) => s,
        Err(_) => return -1,
    };

    let mgr = match get_manager() {
        Some(m) => m,
        None => return -1,
    };

    let actor_ref = match mgr.get_ref(name) {
        Some(r) => r,
        None => return -1,
    };

    // Convert C struct to Rust message and fast_send
    match msg_type {
''')
        # Generate message dispatch for fast_send
        for msg in messages:
            f.write(f'''        {msg.msg_id} => {{
            let c_msg = unsafe {{ &*(msg_data as *const C{msg.name}) }};
            let rust_msg = {msg.name}::from_c_struct(c_msg);
            actor_ref.fast_send(Box::new(rust_msg), None);
        }}
''')

        f.write('''        _ => return -2,
    }

    0
}
''')

def generate_rust_actor_if(messages: List[Message], output_dir: str):
    """Generate RustActorIF header for C++ to call Rust actors."""
    cpp_dir = os.path.join(output_dir, 'cpp')

    with open(os.path.join(cpp_dir, 'RustActorIF.hpp'), 'w') as f:
        f.write('''/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * RustActorIF - C++ interface to send messages to Rust actors
 */

#pragma once

#include <string>
#include <cstring>
#include "InteropMessages.hpp"

// Forward declare the Rust bridge functions
extern "C" {
    int32_t rust_actor_send(
        const char* actor_name,
        const char* sender_name,
        int32_t msg_type,
        const void* msg_data
    );

    int32_t rust_actor_fast_send(
        const char* actor_name,
        const char* sender_name,
        int32_t msg_type,
        const void* msg_data
    );

    int32_t rust_actor_exists(const char* name);
}

namespace interop {

/**
 * RustActorIF - Interface for C++ actors to send messages to Rust actors
 *
 * Usage:
 *   RustActorIF rust_actor("my_rust_actor", "my_cpp_actor");
 *   rust_actor.send(msg::Ping{42});           // async
 *   rust_actor.fast_send(msg::Ping{42});      // sync (blocks until processed)
 */
class RustActorIF {
public:
    RustActorIF(const std::string& actor_name, const std::string& sender_name = "")
        : actor_name_(actor_name)
        , sender_name_(sender_name) {}

    /**
     * Send a message asynchronously (fire-and-forget)
     * Returns 0 on success, -1 if actor not found
     */
    template<typename Msg>
    int send(const Msg& msg) const {
        auto c_msg = msg.to_c_struct();
        return rust_actor_send(
            actor_name_.c_str(),
            sender_name_.empty() ? nullptr : sender_name_.c_str(),
            Msg::ID,
            &c_msg
        );
    }

    /**
     * Send a message synchronously (blocks until message is processed)
     * Returns 0 on success, -1 if actor not found
     */
    template<typename Msg>
    int fast_send(const Msg& msg) const {
        auto c_msg = msg.to_c_struct();
        return rust_actor_fast_send(
            actor_name_.c_str(),
            sender_name_.empty() ? nullptr : sender_name_.c_str(),
            Msg::ID,
            &c_msg
        );
    }

    bool exists() const {
        return rust_actor_exists(actor_name_.c_str()) != 0;
    }

    const std::string& name() const { return actor_name_; }

private:
    std::string actor_name_;
    std::string sender_name_;
};

} // namespace interop
''')

def generate_cpp_actor_if(messages: List[Message], output_dir: str):
    """Generate CppActorIF module for Rust to call C++ actors."""
    rust_dir = os.path.join(output_dir, 'rust')

    with open(os.path.join(rust_dir, 'cpp_actor_if.rs'), 'w') as f:
        f.write('''//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h
//!
//! CppActorIF - Rust interface to send messages to C++ actors

#![allow(dead_code)]

use std::ffi::CString;
use std::os::raw::{c_char, c_int, c_void};

use crate::interop_messages::*;

// C++ bridge functions - resolved at final link time (no #[link] attribute)
// The final executable must link both Rust and C++ code together
extern "C" {
    fn cpp_actor_send(
        actor_name: *const c_char,
        sender_name: *const c_char,
        msg_type: c_int,
        msg_data: *const c_void,
    ) -> c_int;

    fn cpp_actor_fast_send(
        actor_name: *const c_char,
        sender_name: *const c_char,
        msg_type: c_int,
        msg_data: *const c_void,
    ) -> c_int;

    fn cpp_actor_exists(name: *const c_char) -> c_int;
}

/// Trait for messages that can be sent via FFI
pub trait InteropMessage {
    type CStruct;
    const MSG_ID: i32;
    fn to_c_struct(&self) -> Self::CStruct;
}

''')
        # Implement InteropMessage for each message type
        for msg in messages:
            f.write(f'''impl InteropMessage for {msg.name} {{
    type CStruct = C{msg.name};
    const MSG_ID: i32 = {msg.msg_id};
    fn to_c_struct(&self) -> Self::CStruct {{
        {msg.name}::to_c_struct(self)
    }}
}}

''')

        f.write('''/// CppActorIF - Interface for Rust actors to send messages to C++ actors
///
/// Usage:
///   let cpp_actor = CppActorIF::new("my_cpp_actor", "my_rust_actor");
///   cpp_actor.send(&Ping { count: 42 });           // async
///   cpp_actor.fast_send(&Ping { count: 42 });      // sync (blocks until processed)
pub struct CppActorIF {
    actor_name: CString,
    sender_name: Option<CString>,
}

impl CppActorIF {
    pub fn new(actor_name: &str, sender_name: Option<&str>) -> Self {
        CppActorIF {
            actor_name: CString::new(actor_name).unwrap(),
            sender_name: sender_name.map(|s| CString::new(s).unwrap()),
        }
    }

    /// Send a message asynchronously (fire-and-forget)
    /// Returns 0 on success, -1 if actor not found
    pub fn send<M: InteropMessage>(&self, msg: &M) -> i32 {
        let c_msg = msg.to_c_struct();
        let sender_ptr = self.sender_name
            .as_ref()
            .map(|s| s.as_ptr())
            .unwrap_or(std::ptr::null());
        unsafe {
            cpp_actor_send(
                self.actor_name.as_ptr(),
                sender_ptr,
                M::MSG_ID,
                &c_msg as *const _ as *const c_void,
            )
        }
    }

    /// Send a message synchronously (blocks until message is processed)
    /// Returns 0 on success, -1 if actor not found
    pub fn fast_send<M: InteropMessage>(&self, msg: &M) -> i32 {
        let c_msg = msg.to_c_struct();
        let sender_ptr = self.sender_name
            .as_ref()
            .map(|s| s.as_ptr())
            .unwrap_or(std::ptr::null());
        unsafe {
            cpp_actor_fast_send(
                self.actor_name.as_ptr(),
                sender_ptr,
                M::MSG_ID,
                &c_msg as *const _ as *const c_void,
            )
        }
    }

    pub fn exists(&self) -> bool {
        unsafe { cpp_actor_exists(self.actor_name.as_ptr()) != 0 }
    }

    pub fn name(&self) -> &str {
        self.actor_name.to_str().unwrap()
    }
}
''')

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input_header> <output_dir>")
        sys.exit(1)

    header_path = sys.argv[1]
    output_dir = sys.argv[2]

    print(f"Parsing {header_path}...")
    messages = parse_header(header_path)
    print(f"Found {len(messages)} messages:")
    for msg in messages:
        fields_info = ', '.join(
            f"{f.name}:{f.c_type}{'['+str(f.array_size)+']' if f.array_size else ''}"
            for f in msg.fields
        )
        print(f"  - {msg.name} (ID={msg.msg_id}): {fields_info}")

    print(f"\nGenerating C++ code...")
    generate_cpp_messages(messages, output_dir)
    generate_cpp_bridge(messages, output_dir)
    generate_rust_actor_if(messages, output_dir)

    print(f"Generating Rust code...")
    generate_rust_messages(messages, output_dir)
    generate_rust_bridge(messages, output_dir)
    generate_cpp_actor_if(messages, output_dir)

    print(f"\nGenerated files in {output_dir}/")
    print("  cpp/InteropMessages.hpp     - C++ message classes in msg:: namespace")
    print("  cpp/CppActorBridge.hpp/cpp  - C++ bridge callable from Rust")
    print("  cpp/RustActorIF.hpp         - C++ interface to Rust actors")
    print("  rust/interop_messages.rs    - Rust message structs")
    print("  rust/rust_actor_bridge.rs   - Rust bridge callable from C++")
    print("  rust/cpp_actor_if.rs        - Rust interface to C++ actors")

if __name__ == '__main__':
    main()
